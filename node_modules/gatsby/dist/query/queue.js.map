{"version":3,"sources":["../../src/query/queue.js"],"names":["Queue","require","store","FastMemoryStore","queryRunner","websocketManager","GraphQLRunner","createBaseOptions","concurrent","Number","process","env","GATSBY_EXPERIMENTAL_QUERY_CONCURRENCY","createBuildQueue","graphqlRunner","handler","queryJob","callback","then","result","catch","createDevelopQueue","getRunner","queueOptions","priority","job","cb","id","activePaths","has","merge","oldTask","newTask","isPage","emitPageData","emitStaticQueryData","error","processBatch","queue","jobs","activity","length","Promise","resolve","reject","tick","on","gc","removeAllListeners","err","forEach","push","module","exports"],"mappings":"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","sourcesContent":["const Queue = require(`better-queue`)\nconst { store } = require(`../redux`)\nconst FastMemoryStore = require(`../query/better-queue-custom-store`)\nconst queryRunner = require(`../query/query-runner`)\nconst websocketManager = require(`../utils/websocket-manager`)\nconst GraphQLRunner = require(`./graphql-runner`)\n\nconst createBaseOptions = () => {\n  return {\n    concurrent: Number(process.env.GATSBY_EXPERIMENTAL_QUERY_CONCURRENCY) || 4,\n    // eslint-disable-next-line new-cap\n    store: FastMemoryStore(),\n  }\n}\n\nconst createBuildQueue = () => {\n  const graphqlRunner = new GraphQLRunner(store)\n  const handler = (queryJob, callback) =>\n    queryRunner(graphqlRunner, queryJob)\n      .then(result => callback(null, result))\n      .catch(callback)\n  return new Queue(handler, createBaseOptions())\n}\n\nconst createDevelopQueue = getRunner => {\n  const queueOptions = {\n    ...createBaseOptions(),\n    priority: (job, cb) => {\n      if (job.id && websocketManager.activePaths.has(job.id)) {\n        cb(null, 10)\n      } else {\n        cb(null, 1)\n      }\n    },\n    merge: (oldTask, newTask, cb) => {\n      cb(null, newTask)\n    },\n  }\n\n  const handler = (queryJob, callback) => {\n    queryRunner(getRunner(), queryJob).then(\n      result => {\n        if (queryJob.isPage) {\n          websocketManager.emitPageData({\n            result,\n            id: queryJob.id,\n          })\n        } else {\n          websocketManager.emitStaticQueryData({\n            result,\n            id: queryJob.id,\n          })\n        }\n\n        callback(null, result)\n      },\n      error => callback(error)\n    )\n  }\n\n  return new Queue(handler, queueOptions)\n}\n\n/**\n * Returns a promise that pushes jobs onto queue and resolves onces\n * they're all finished processing (or rejects if one or more jobs\n * fail)\n * Note: queue is reused in develop so make sure to thoroughly cleanup hooks\n */\nconst processBatch = async (queue, jobs, activity) => {\n  if (jobs.length === 0) {\n    return Promise.resolve()\n  }\n\n  return new Promise((resolve, reject) => {\n    if (activity.tick) {\n      queue.on(`task_finish`, () => activity.tick())\n    }\n\n    const gc = () => {\n      queue.removeAllListeners(`task_failed`)\n      queue.removeAllListeners(`drain`)\n      queue.removeAllListeners(`task_finish`)\n      queue = null\n    }\n\n    queue\n      // Note: the first arg is the path, the second the error\n      .on(`task_failed`, (...err) => {\n        gc()\n        reject(err)\n      })\n      // Note: `drain` fires when all tasks _finish_\n      //       `empty` fires when queue is empty (but tasks are still running)\n      .on(`drain`, () => {\n        gc()\n        resolve()\n      })\n\n    jobs.forEach(job => queue.push(job))\n  })\n}\n\nmodule.exports = {\n  createBuildQueue,\n  createDevelopQueue,\n  processBatch,\n}\n"],"file":"queue.js"}